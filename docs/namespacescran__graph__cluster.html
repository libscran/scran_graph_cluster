<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran_graph_cluster: scran_graph_cluster Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran_graph_cluster
   </div>
   <div id="projectbrief">Graph-based clustering of cells</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scran_graph_cluster Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Graph-based clustering of single-cell data.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html">BuildSnnGraphOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for SNN graph construction.  <a href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphResults.html">BuildSnnGraphResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results of SNN graph construction.  <a href="structscran__graph__cluster_1_1BuildSnnGraphResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__graph__cluster_1_1ClusterLeidenOptions.html">ClusterLeidenOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#a7e0fa194d21cbd65d66186ab2c0dc3c0">cluster_leiden()</a></code>.  <a href="structscran__graph__cluster_1_1ClusterLeidenOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__graph__cluster_1_1ClusterLeidenResults.html">ClusterLeidenResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result of <code><a class="el" href="#a7e0fa194d21cbd65d66186ab2c0dc3c0">cluster_leiden()</a></code>.  <a href="structscran__graph__cluster_1_1ClusterLeidenResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__graph__cluster_1_1ClusterMultilevelOptions.html">ClusterMultilevelOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#a1dfcd4ef567084c288296e77c4daabb5">cluster_multilevel()</a></code>.  <a href="structscran__graph__cluster_1_1ClusterMultilevelOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__graph__cluster_1_1ClusterMultilevelResults.html">ClusterMultilevelResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result of <code><a class="el" href="#a1dfcd4ef567084c288296e77c4daabb5">cluster_multilevel()</a></code>.  <a href="structscran__graph__cluster_1_1ClusterMultilevelResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__graph__cluster_1_1ClusterWalktrapOptions.html">ClusterWalktrapOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#aa6b332af6bc15dc8fcc0d974c4d4fc2b">cluster_walktrap()</a></code>.  <a href="structscran__graph__cluster_1_1ClusterWalktrapOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__graph__cluster_1_1ClusterWalktrapResults.html">ClusterWalktrapResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result of <code><a class="el" href="#aa6b332af6bc15dc8fcc0d974c4d4fc2b">cluster_walktrap()</a></code>.  <a href="structscran__graph__cluster_1_1ClusterWalktrapResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac4dcb712a766e6c187e61289ce5bd2ab" id="r_ac4dcb712a766e6c187e61289ce5bd2ab"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4dcb712a766e6c187e61289ce5bd2ab">DefaultNode</a></td></tr>
<tr class="separator:ac4dcb712a766e6c187e61289ce5bd2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94345511cbc563ce789fa8f6883bbee2" id="r_a94345511cbc563ce789fa8f6883bbee2"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94345511cbc563ce789fa8f6883bbee2">DefaultWeight</a></td></tr>
<tr class="separator:a94345511cbc563ce789fa8f6883bbee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afd97a61efb1483698423b201e4e7dd3f" id="r_afd97a61efb1483698423b201e4e7dd3f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd97a61efb1483698423b201e4e7dd3f">SnnWeightScheme</a> : char { <b>RANKED</b>
, <b>NUMBER</b>
, <b>JACCARD</b>
 }</td></tr>
<tr class="separator:afd97a61efb1483698423b201e4e7dd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae1a71cbc88649a7e3e19e677b200f7fe" id="r_ae1a71cbc88649a7e3e19e677b200f7fe"><td class="memTemplParams" colspan="2">template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Index_ , class GetNeighbors_ , class GetIndex_ &gt; </td></tr>
<tr class="memitem:ae1a71cbc88649a7e3e19e677b200f7fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae1a71cbc88649a7e3e19e677b200f7fe">build_snn_graph</a> (Index_ num_cells, GetNeighbors_ get_neighbors, GetIndex_ get_index, const <a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html">BuildSnnGraphOptions</a> &amp;options, <a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphResults.html">BuildSnnGraphResults</a>&lt; Node_, Weight_ &gt; &amp;output)</td></tr>
<tr class="separator:ae1a71cbc88649a7e3e19e677b200f7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1cdafb49d79cbb879e9c16b75afb12" id="r_a3e1cdafb49d79cbb879e9c16b75afb12"><td class="memTemplParams" colspan="2">template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Index_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:a3e1cdafb49d79cbb879e9c16b75afb12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphResults.html">BuildSnnGraphResults</a>&lt; Node_, Weight_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e1cdafb49d79cbb879e9c16b75afb12">build_snn_graph</a> (const <a class="elRef" href="https://knncolle.github.io/knncolle/namespaceknncolle.html#a97693d779b6041859ffa0ef2d9c1500b">knncolle::NeighborList</a>&lt; Index_, Distance_ &gt; &amp;neighbors, const <a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html">BuildSnnGraphOptions</a> &amp;options)</td></tr>
<tr class="separator:a3e1cdafb49d79cbb879e9c16b75afb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4bf6dca952c29cafc91ac49ce118ef" id="r_a7b4bf6dca952c29cafc91ac49ce118ef"><td class="memTemplParams" colspan="2">template&lt;typename Node_  = int, typename Weight_  = double, typename Index_ &gt; </td></tr>
<tr class="memitem:a7b4bf6dca952c29cafc91ac49ce118ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphResults.html">BuildSnnGraphResults</a>&lt; Node_, Weight_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b4bf6dca952c29cafc91ac49ce118ef">build_snn_graph</a> (const std::vector&lt; std::vector&lt; Index_ &gt; &gt; &amp;neighbors, const <a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html">BuildSnnGraphOptions</a> &amp;options)</td></tr>
<tr class="separator:a7b4bf6dca952c29cafc91ac49ce118ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4a0a02c439c6c87e6f08a33b17c03d" id="r_afb4a0a02c439c6c87e6f08a33b17c03d"><td class="memTemplParams" colspan="2">template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Index_ , typename Input_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:afb4a0a02c439c6c87e6f08a33b17c03d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphResults.html">BuildSnnGraphResults</a>&lt; Node_, Weight_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb4a0a02c439c6c87e6f08a33b17c03d">build_snn_graph</a> (const <a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html">knncolle::Prebuilt</a>&lt; Index_, Input_, Distance_ &gt; &amp;prebuilt, const <a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html">BuildSnnGraphOptions</a> &amp;options)</td></tr>
<tr class="separator:afb4a0a02c439c6c87e6f08a33b17c03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbbb847cfdc359de4e2e162b0e623f7" id="r_a9cbbb847cfdc359de4e2e162b0e623f7"><td class="memTemplParams" colspan="2">template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Index_ , typename Input_ , typename Distance_ , class Matrix_  = knncolle::Matrix&lt;Index_, Input_&gt;&gt; </td></tr>
<tr class="memitem:a9cbbb847cfdc359de4e2e162b0e623f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphResults.html">BuildSnnGraphResults</a>&lt; Node_, Weight_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9cbbb847cfdc359de4e2e162b0e623f7">build_snn_graph</a> (std::size_t num_dims, Index_ num_cells, const Input_ *data, const <a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Builder.html">knncolle::Builder</a>&lt; Index_, Input_, Distance_, Matrix_ &gt; &amp;knn_method, const <a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html">BuildSnnGraphOptions</a> &amp;options)</td></tr>
<tr class="separator:a9cbbb847cfdc359de4e2e162b0e623f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0fa194d21cbd65d66186ab2c0dc3c0" id="r_a7e0fa194d21cbd65d66186ab2c0dc3c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e0fa194d21cbd65d66186ab2c0dc3c0">cluster_leiden</a> (const igraph_t *graph, const igraph_vector_t *weights, const <a class="el" href="structscran__graph__cluster_1_1ClusterLeidenOptions.html">ClusterLeidenOptions</a> &amp;options, <a class="el" href="structscran__graph__cluster_1_1ClusterLeidenResults.html">ClusterLeidenResults</a> &amp;output)</td></tr>
<tr class="separator:a7e0fa194d21cbd65d66186ab2c0dc3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668653597ebdff4b8a560bf092d5bd8b" id="r_a668653597ebdff4b8a560bf092d5bd8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscran__graph__cluster_1_1ClusterLeidenResults.html">ClusterLeidenResults</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a668653597ebdff4b8a560bf092d5bd8b">cluster_leiden</a> (const raiigraph::Graph &amp;graph, const std::vector&lt; igraph_real_t &gt; &amp;weights, const <a class="el" href="structscran__graph__cluster_1_1ClusterLeidenOptions.html">ClusterLeidenOptions</a> &amp;options)</td></tr>
<tr class="separator:a668653597ebdff4b8a560bf092d5bd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfcd4ef567084c288296e77c4daabb5" id="r_a1dfcd4ef567084c288296e77c4daabb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dfcd4ef567084c288296e77c4daabb5">cluster_multilevel</a> (const igraph_t *graph, const igraph_vector_t *weights, const <a class="el" href="structscran__graph__cluster_1_1ClusterMultilevelOptions.html">ClusterMultilevelOptions</a> &amp;options, <a class="el" href="structscran__graph__cluster_1_1ClusterMultilevelResults.html">ClusterMultilevelResults</a> &amp;output)</td></tr>
<tr class="separator:a1dfcd4ef567084c288296e77c4daabb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527ad4b8b48f5c976fa37ac0a25b4081" id="r_a527ad4b8b48f5c976fa37ac0a25b4081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscran__graph__cluster_1_1ClusterMultilevelResults.html">ClusterMultilevelResults</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a527ad4b8b48f5c976fa37ac0a25b4081">cluster_multilevel</a> (const raiigraph::Graph &amp;graph, const std::vector&lt; igraph_real_t &gt; &amp;weights, const <a class="el" href="structscran__graph__cluster_1_1ClusterMultilevelOptions.html">ClusterMultilevelOptions</a> &amp;options)</td></tr>
<tr class="separator:a527ad4b8b48f5c976fa37ac0a25b4081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b332af6bc15dc8fcc0d974c4d4fc2b" id="r_aa6b332af6bc15dc8fcc0d974c4d4fc2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6b332af6bc15dc8fcc0d974c4d4fc2b">cluster_walktrap</a> (const igraph_t *graph, const igraph_vector_t *weights, const <a class="el" href="structscran__graph__cluster_1_1ClusterWalktrapOptions.html">ClusterWalktrapOptions</a> &amp;options, <a class="el" href="structscran__graph__cluster_1_1ClusterWalktrapResults.html">ClusterWalktrapResults</a> &amp;output)</td></tr>
<tr class="separator:aa6b332af6bc15dc8fcc0d974c4d4fc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82ceda0bfd680ca4439dc83c7fe6939" id="r_aa82ceda0bfd680ca4439dc83c7fe6939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscran__graph__cluster_1_1ClusterWalktrapResults.html">ClusterWalktrapResults</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa82ceda0bfd680ca4439dc83c7fe6939">cluster_walktrap</a> (const raiigraph::Graph &amp;graph, const std::vector&lt; igraph_real_t &gt; &amp;weights, const <a class="el" href="structscran__graph__cluster_1_1ClusterWalktrapOptions.html">ClusterWalktrapOptions</a> &amp;options)</td></tr>
<tr class="separator:aa82ceda0bfd680ca4439dc83c7fe6939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783e1e6c915120239eb0638c74bbdb06" id="r_a783e1e6c915120239eb0638c74bbdb06"><td class="memTemplParams" colspan="2">template&lt;typename Vertex_ &gt; </td></tr>
<tr class="memitem:a783e1e6c915120239eb0638c74bbdb06"><td class="memTemplItemLeft" align="right" valign="top">raiigraph::Graph&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a783e1e6c915120239eb0638c74bbdb06">edges_to_graph</a> (size_t double_edges, const Vertex_ *edges, size_t num_vertices, igraph_bool_t directed)</td></tr>
<tr class="separator:a783e1e6c915120239eb0638c74bbdb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Graph-based clustering of single-cell data. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac4dcb712a766e6c187e61289ce5bd2ab" name="ac4dcb712a766e6c187e61289ce5bd2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dcb712a766e6c187e61289ce5bd2ab">&#9670;&#160;</a></span>DefaultNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="#ac4dcb712a766e6c187e61289ce5bd2ab">scran_graph_cluster::DefaultNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default type for the node indices. Set to <code>igraph_integer_t</code> if <b>igraph</b> is available. </p>

</div>
</div>
<a id="a94345511cbc563ce789fa8f6883bbee2" name="a94345511cbc563ce789fa8f6883bbee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94345511cbc563ce789fa8f6883bbee2">&#9670;&#160;</a></span>DefaultWeight</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="#a94345511cbc563ce789fa8f6883bbee2">scran_graph_cluster::DefaultWeight</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default type for the edge weights. Set to <code>igraph_real_t</code> if <b>igraph</b> is available. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afd97a61efb1483698423b201e4e7dd3f" name="afd97a61efb1483698423b201e4e7dd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd97a61efb1483698423b201e4e7dd3f">&#9670;&#160;</a></span>SnnWeightScheme</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#afd97a61efb1483698423b201e4e7dd3f">scran_graph_cluster::SnnWeightScheme</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Choices for the edge weighting scheme during graph construction. Let \(k\) be the number of nearest neighbors for each node.</p>
<ul>
<li><code>RANKED</code> defines the weight between two nodes as \(k - r/2\) where \(r\) is the smallest sum of ranks for any shared neighboring node (Xu and Su, 2015). For the purposes of this ranking, each node has a rank of zero in its own nearest-neighbor set. More shared neighbors, or shared neighbors that are close to both observations, will generally yield larger weights.</li>
<li><code>NUMBER</code> defines the weight between two nodes as the number of shared nearest neighbors between them. The weight can range from zero to \(k + 1\), as the node itself is included in its own nearest-neighbor set. This is a simpler scheme that is also slightly faster but does not account for the ranking of neighbors within each set.</li>
<li><code>JACCARD</code> defines the weight between two nodes as the Jaccard index of their neighbor sets, motivated by the algorithm used by the <a href="https://cran.r-project.org/package=seurat"><b>Seurat</b> R package</a>. This weight can range from zero to 1, and is a monotonic transformation of the weight used by <code>NUMBER</code>.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd>Xu C and Su Z (2015). Identification of cell types from single-cell transcriptomes using a novel clustering method. <em>Bioinformatics</em> 31, 1974-80 </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae1a71cbc88649a7e3e19e677b200f7fe" name="ae1a71cbc88649a7e3e19e677b200f7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a71cbc88649a7e3e19e677b200f7fe">&#9670;&#160;</a></span>build_snn_graph() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Index_ , class GetNeighbors_ , class GetIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_graph_cluster::build_snn_graph </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>num_cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetNeighbors_</td>          <td class="paramname"><span class="paramname"><em>get_neighbors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetIndex_</td>          <td class="paramname"><span class="paramname"><em>get_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html">BuildSnnGraphOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphResults.html">BuildSnnGraphResults</a>&lt; Node_, Weight_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In a shared nearest-neighbor graph, pairs of cells are connected to each other by an edge with weight determined from their shared nearest neighbors. If two cells are close together but have distinct sets of neighbors, the corresponding edge is downweighted as the two cells are unlikely to be part of the same neighborhood. In this manner, highly weighted edges will form within highly interconnected neighborhoods where many cells share the same neighbors. This provides a more sophisticated definition of similarity between cells compared to a simpler (unweighted) nearest neighbor graph that just focuses on immediate proximity.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Node_</td><td>Integer type for the node indices. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type for the edge weights. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the observation index. </td></tr>
    <tr><td class="paramname">GetNeighbors_</td><td>Function that accepts an <code>Index_</code> cell index and returns a (const reference to) a container-like object. The container should be iterable in a range-based for loop, support the <code>[]</code> operator, and have a <code>size()</code> method. </td></tr>
    <tr><td class="paramname">GetIndex_</td><td>Function that accepts an element of the container type returned by <code>GetNeighbors_</code> and returns an <code>Index_</code> containing its observation index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num_cells</td><td>Number of cells in the dataset. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">get_neighbors</td><td>Function that accepts an integer cell index in <code>[0, num_cells)</code> and returns a container of that cell's neighbors. Each element of the container corresponds to a neighbor, and neighbors should be sorted by increasing distance from the cell. The same number of neighbors should be identified for each cell. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">get_index</td><td>Function to return the index of each neighbor, given an element of the container returned by <code>get_neighbors</code>. In trivial cases, this is the identity function but it can be more complex depending on the contents of the inner container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options for graph construction. Note that <code><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html#a18c2ab10d91d0d369ffbb2de073477fc">BuildSnnGraphOptions::num_neighbors</a></code> is ignored here. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>On output, the edges and weights of the SNN graph. The input value is ignored so this can be re-used across multiple calls to <code><a class="el" href="#ae1a71cbc88649a7e3e19e677b200f7fe">build_snn_graph()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e1cdafb49d79cbb879e9c16b75afb12" name="a3e1cdafb49d79cbb879e9c16b75afb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1cdafb49d79cbb879e9c16b75afb12">&#9670;&#160;</a></span>build_snn_graph() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Index_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphResults.html">BuildSnnGraphResults</a>&lt; Node_, Weight_ &gt; scran_graph_cluster::build_snn_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://knncolle.github.io/knncolle/namespaceknncolle.html#a97693d779b6041859ffa0ef2d9c1500b">knncolle::NeighborList</a>&lt; Index_, Distance_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html">BuildSnnGraphOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload to enable convenient usage with pre-computed neighbors from <b>knncolle</b>. Distances are ignored here; only the ordering of neighbor indices is used.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Node_</td><td>Integer type for the node indices. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type for the edge weights. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the neighbor indices. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Floating-point type for the distances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighbors</td><td>Vector of nearest-neighbor search results for each cell. Each entry is a pair containing a vector of neighbor indices and a vector of distances to those neighbors. Neighbors should be sorted by increasing distance. The same number of neighbors should be present for each cell. </td></tr>
    <tr><td class="paramname">options</td><td>Further options for graph construction. Note that <code><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html#a18c2ab10d91d0d369ffbb2de073477fc">BuildSnnGraphOptions::num_neighbors</a></code> is ignored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges and weights of the SNN graph. </dd></dl>

</div>
</div>
<a id="a7b4bf6dca952c29cafc91ac49ce118ef" name="a7b4bf6dca952c29cafc91ac49ce118ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4bf6dca952c29cafc91ac49ce118ef">&#9670;&#160;</a></span>build_snn_graph() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Node_  = int, typename Weight_  = double, typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphResults.html">BuildSnnGraphResults</a>&lt; Node_, Weight_ &gt; scran_graph_cluster::build_snn_graph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Index_ &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html">BuildSnnGraphOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload to enable convenient usage with pre-computed neighbors from <b>knncolle</b>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Node_</td><td>Integer type for the node indices. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type for the edge weights. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the neighbor indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighbors</td><td>Vector of vectors of indices for the neighbors for each cell, sorted by increasing distance. It is generally expected that the same number of neighbors are present for each cell, though differences between cells are supported. </td></tr>
    <tr><td class="paramname">options</td><td>Further options for graph construction. Note that <code><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html#a18c2ab10d91d0d369ffbb2de073477fc">BuildSnnGraphOptions::num_neighbors</a></code> is ignored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges and weights of the SNN graph. </dd></dl>

</div>
</div>
<a id="afb4a0a02c439c6c87e6f08a33b17c03d" name="afb4a0a02c439c6c87e6f08a33b17c03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4a0a02c439c6c87e6f08a33b17c03d">&#9670;&#160;</a></span>build_snn_graph() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Index_ , typename Input_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphResults.html">BuildSnnGraphResults</a>&lt; Node_, Weight_ &gt; scran_graph_cluster::build_snn_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html">knncolle::Prebuilt</a>&lt; Index_, Input_, Distance_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prebuilt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html">BuildSnnGraphOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload to enable convenient usage with a prebuilt nearest-neighbor search index from <b>knncolle</b>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Node_</td><td>Integer type for the node indices. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type for the edge weights. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the cell index. </td></tr>
    <tr><td class="paramname">Input_</td><td>Numeric type for the input data used to build the search index. This is only required to define the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html">knncolle::Prebuilt</a></code> class and is otherwise ignored. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Floating-point type for the distances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prebuilt</td><td>A prebuilt nearest-neighbor search index on the cells of interest. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options for graph construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges and weights of the SNN graph. </dd></dl>

</div>
</div>
<a id="a9cbbb847cfdc359de4e2e162b0e623f7" name="a9cbbb847cfdc359de4e2e162b0e623f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbbb847cfdc359de4e2e162b0e623f7">&#9670;&#160;</a></span>build_snn_graph() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Index_ , typename Input_ , typename Distance_ , class Matrix_  = knncolle::Matrix&lt;Index_, Input_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphResults.html">BuildSnnGraphResults</a>&lt; Node_, Weight_ &gt; scran_graph_cluster::build_snn_graph </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>num_cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Input_ *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Builder.html">knncolle::Builder</a>&lt; Index_, Input_, Distance_, Matrix_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>knn_method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__graph__cluster_1_1BuildSnnGraphOptions.html">BuildSnnGraphOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload to enable convenient usage with a column-major array of cell coordinates.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Node_</td><td>Integer type for the node indices. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type for the edge weights. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the cell index. </td></tr>
    <tr><td class="paramname">Input_</td><td>Numeric type for the input data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Floating-point type for the distances. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Class of the input data matrix for the neighbor search. This should satisfy the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Matrix.html">knncolle::Matrix</a></code> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num_dims</td><td>Number of dimensions for the cell coordinates. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_cells</td><td>Number of cells in the dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a <code>num_dims</code>-by-<code>num_cells</code> column-major array of cell coordinates where rows are dimensions and columns are cells. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">knn_method</td><td>Specification of the nearest-neighbor search algorithm, e.g., <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1VptreeBuilder.html">knncolle::VptreeBuilder</a></code>, <code>knncolle::KmknnBuilder</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options for graph construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges and weights of the SNN graph. </dd></dl>

</div>
</div>
<a id="a7e0fa194d21cbd65d66186ab2c0dc3c0" name="a7e0fa194d21cbd65d66186ab2c0dc3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0fa194d21cbd65d66186ab2c0dc3c0">&#9670;&#160;</a></span>cluster_leiden() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran_graph_cluster::cluster_leiden </td>
          <td>(</td>
          <td class="paramtype">const igraph_t *</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const igraph_vector_t *</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__graph__cluster_1_1ClusterLeidenOptions.html">ClusterLeidenOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscran__graph__cluster_1_1ClusterLeidenResults.html">ClusterLeidenResults</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Run the Leiden community detection algorithm on a pre-constructed graph to obtain communities of highly inter-connected nodes. See <a href="https://igraph.org/c/doc/igraph-Community.html#igraph_community_leiden">here</a> for more details on the Leiden algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">graph</td><td>An existing graph. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">weights</td><td>Pointer to an array of weights of length equal to the number of edges in <code>graph</code>. This should be in the same order as the edge list in <code>graph</code>. Alternatively <code>NULL</code>, if the graph is unweighted. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>On output, this is filtered with the clustering results. The input value is ignored, so this object can be re-used across multiple calls to <code><a class="el" href="#a7e0fa194d21cbd65d66186ab2c0dc3c0">cluster_leiden()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a668653597ebdff4b8a560bf092d5bd8b" name="a668653597ebdff4b8a560bf092d5bd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668653597ebdff4b8a560bf092d5bd8b">&#9670;&#160;</a></span>cluster_leiden() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__graph__cluster_1_1ClusterLeidenResults.html">ClusterLeidenResults</a> scran_graph_cluster::cluster_leiden </td>
          <td>(</td>
          <td class="paramtype">const raiigraph::Graph &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; igraph_real_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__graph__cluster_1_1ClusterLeidenOptions.html">ClusterLeidenOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a7e0fa194d21cbd65d66186ab2c0dc3c0">cluster_leiden()</a></code> that accepts C++ containers instead of the raw <b>igraph</b> pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>An existing graph. </td></tr>
    <tr><td class="paramname">weights</td><td>Vector of weights of length equal to the number of edges in <code>graph</code>. This should be in the same order as the edge list in <code>graph</code>. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Clustering results for the nodes of the graph. </dd></dl>

</div>
</div>
<a id="a1dfcd4ef567084c288296e77c4daabb5" name="a1dfcd4ef567084c288296e77c4daabb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfcd4ef567084c288296e77c4daabb5">&#9670;&#160;</a></span>cluster_multilevel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran_graph_cluster::cluster_multilevel </td>
          <td>(</td>
          <td class="paramtype">const igraph_t *</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const igraph_vector_t *</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__graph__cluster_1_1ClusterMultilevelOptions.html">ClusterMultilevelOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscran__graph__cluster_1_1ClusterMultilevelResults.html">ClusterMultilevelResults</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Run the multi-level community detection algorithm on a pre-constructed graph to obtain communities of highly inter-connected nodes. See <a href="https://igraph.org/c/doc/igraph-Community.html#igraph_community_multilevel">here</a> for more details on the multi-level algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">graph</td><td>An existing graph. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">weights</td><td>Pointer to an array of weights of length equal to the number of edges in <code>graph</code>. This should be in the same order as the edge list in <code>graph</code>. Alternatively <code>NULL</code>, if the graph is unweighted. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>On output, this is filtered with the clustering results. The input value is ignored, so this object can be re-used across multiple calls to <code><a class="el" href="#a1dfcd4ef567084c288296e77c4daabb5">cluster_multilevel()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a527ad4b8b48f5c976fa37ac0a25b4081" name="a527ad4b8b48f5c976fa37ac0a25b4081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527ad4b8b48f5c976fa37ac0a25b4081">&#9670;&#160;</a></span>cluster_multilevel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__graph__cluster_1_1ClusterMultilevelResults.html">ClusterMultilevelResults</a> scran_graph_cluster::cluster_multilevel </td>
          <td>(</td>
          <td class="paramtype">const raiigraph::Graph &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; igraph_real_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__graph__cluster_1_1ClusterMultilevelOptions.html">ClusterMultilevelOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a1dfcd4ef567084c288296e77c4daabb5">cluster_multilevel()</a></code> that accepts C++ containers instead of the raw <b>igraph</b> pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>An existing graph. </td></tr>
    <tr><td class="paramname">weights</td><td>Vector of weights of length equal to the number of edges in <code>graph</code>. This should be in the same order as the edge list in <code>graph</code>. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Clustering results for the nodes of the graph. </dd></dl>

</div>
</div>
<a id="aa6b332af6bc15dc8fcc0d974c4d4fc2b" name="aa6b332af6bc15dc8fcc0d974c4d4fc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b332af6bc15dc8fcc0d974c4d4fc2b">&#9670;&#160;</a></span>cluster_walktrap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran_graph_cluster::cluster_walktrap </td>
          <td>(</td>
          <td class="paramtype">const igraph_t *</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const igraph_vector_t *</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__graph__cluster_1_1ClusterWalktrapOptions.html">ClusterWalktrapOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscran__graph__cluster_1_1ClusterWalktrapResults.html">ClusterWalktrapResults</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Run the Walktrap community detection algorithm on a pre-constructed graph to obtain communities of highly inter-connected nodes. See <a href="https://igraph.org/c/doc/igraph-Community.html#igraph_community_walktrap">here</a> for more details on the Walktrap algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">graph</td><td>An existing graph. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">weights</td><td>Pointer to an array of weights of length equal to the number of edges in <code>graph</code>. This should be in the same order as the edge list in <code>graph</code>. Alternatively <code>NULL</code>, if the graph is unweighted. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>On output, this is filtered with the clustering results. The input value is ignored, so this object can be re-used across multiple calls to <code><a class="el" href="#aa6b332af6bc15dc8fcc0d974c4d4fc2b">cluster_walktrap()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa82ceda0bfd680ca4439dc83c7fe6939" name="aa82ceda0bfd680ca4439dc83c7fe6939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82ceda0bfd680ca4439dc83c7fe6939">&#9670;&#160;</a></span>cluster_walktrap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__graph__cluster_1_1ClusterWalktrapResults.html">ClusterWalktrapResults</a> scran_graph_cluster::cluster_walktrap </td>
          <td>(</td>
          <td class="paramtype">const raiigraph::Graph &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; igraph_real_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__graph__cluster_1_1ClusterWalktrapOptions.html">ClusterWalktrapOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aa6b332af6bc15dc8fcc0d974c4d4fc2b">cluster_walktrap()</a></code> that accepts C++ containers instead of the raw <b>igraph</b> pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>An existing graph. </td></tr>
    <tr><td class="paramname">weights</td><td>Vector of weights of length equal to the number of edges in <code>graph</code>. This should be in the same order as the edge list in <code>graph</code>. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Clustering results for the nodes of the graph. </dd></dl>

</div>
</div>
<a id="a783e1e6c915120239eb0638c74bbdb06" name="a783e1e6c915120239eb0638c74bbdb06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783e1e6c915120239eb0638c74bbdb06">&#9670;&#160;</a></span>edges_to_graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vertex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">raiigraph::Graph scran_graph_cluster::edges_to_graph </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>double_edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vertex_ *</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_vertices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">igraph_bool_t</td>          <td class="paramname"><span class="paramname"><em>directed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <code>raiigraph:Graph</code> object from the edges.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vertex_</td><td>Integer type for the vertex IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">double_edges</td><td>The number of edges times two. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>Pointer to an array of length <code>double_edges</code>. <code>edges[2*i]</code> and <code>edges[2*i+1]</code> define the vertices for edge <code>i</code>. For directed graphs, the edge goes from the first vertex to the second vertex. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_vertices</td><td>Number of vertices in the graph. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">directed</td><td>Whether the graph is directed. This should be one of <code>IGRAPH_DIRECTED</code> or <code>IGRAPH_UNDIRECTED</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A graph created from <code>edges</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
