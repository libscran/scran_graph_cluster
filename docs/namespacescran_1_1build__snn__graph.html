<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran_snn_clustering: scran::build_snn_graph Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran_snn_clustering
   </div>
   <div id="projectbrief">Graph-based clustering of cells</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>scran</b></li><li class="navelem"><a class="el" href="namespacescran_1_1build__snn__graph.html">build_snn_graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scran::build_snn_graph Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Build a shared nearest-neighbor graph with cells as nodes.  
<a href="namespacescran_1_1build__snn__graph.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1build__snn__graph_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscran_1_1build__snn__graph_1_1Options.html" title="Options for SNN graph construction.">Options</a> for SNN graph construction.  <a href="structscran_1_1build__snn__graph_1_1Options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1build__snn__graph_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscran_1_1build__snn__graph_1_1Results.html" title="Results of SNN graph construction.">Results</a> of SNN graph construction.  <a href="structscran_1_1build__snn__graph_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1a0949d64c32d94355e3a3ab92d4a103" id="r_a1a0949d64c32d94355e3a3ab92d4a103"><td class="memItemLeft" align="right" valign="top"><a id="a1a0949d64c32d94355e3a3ab92d4a103" name="a1a0949d64c32d94355e3a3ab92d4a103"></a>
<a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">typedef</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultNode</b></td></tr>
<tr class="separator:a1a0949d64c32d94355e3a3ab92d4a103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66420baa184bad1c09d7719a020b15e2" id="r_a66420baa184bad1c09d7719a020b15e2"><td class="memItemLeft" align="right" valign="top"><a id="a66420baa184bad1c09d7719a020b15e2" name="a66420baa184bad1c09d7719a020b15e2"></a>
<a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">typedef</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">double</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultWeight</b></td></tr>
<tr class="separator:a66420baa184bad1c09d7719a020b15e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a610e9e4165fe86b9903b9dd368695358" id="r_a610e9e4165fe86b9903b9dd368695358"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescran_1_1build__snn__graph.html#a610e9e4165fe86b9903b9dd368695358">Scheme</a> : char { <b>RANKED</b>
, <b>NUMBER</b>
, <b>JACCARD</b>
 }</td></tr>
<tr class="separator:a610e9e4165fe86b9903b9dd368695358"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad7bb15027d07c0c217c0082746bb69ed" id="r_ad7bb15027d07c0c217c0082746bb69ed"><td class="memTemplParams" colspan="2">template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, class GetNeighbors_ , class GetIndex_ &gt; </td></tr>
<tr class="memitem:ad7bb15027d07c0c217c0082746bb69ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">compute</a> (size_t num_cells, GetNeighbors_ get_neighbors, GetIndex_ get_index, const <a class="el" href="structscran_1_1build__snn__graph_1_1Options.html">Options</a> &amp;options, <a class="el" href="structscran_1_1build__snn__graph_1_1Results.html">Results</a>&lt; Node_, Weight_ &gt; &amp;output)</td></tr>
<tr class="separator:ad7bb15027d07c0c217c0082746bb69ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add74d72ecdcd9e644641c06f2760a6cf" id="r_add74d72ecdcd9e644641c06f2760a6cf"><td class="memTemplParams" colspan="2">template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Index_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:add74d72ecdcd9e644641c06f2760a6cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1build__snn__graph_1_1Results.html">Results</a>&lt; Node_, Weight_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran_1_1build__snn__graph.html#add74d72ecdcd9e644641c06f2760a6cf">compute</a> (const knncolle::NeighborList&lt; Index_, Distance_ &gt; &amp;neighbors, const <a class="el" href="structscran_1_1build__snn__graph_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:add74d72ecdcd9e644641c06f2760a6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232e3a8285f1e19655e9bdc448c3a9e0" id="r_a232e3a8285f1e19655e9bdc448c3a9e0"><td class="memTemplParams" colspan="2">template&lt;typename Node_  = int, typename Weight_  = double, typename Index_ &gt; </td></tr>
<tr class="memitem:a232e3a8285f1e19655e9bdc448c3a9e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1build__snn__graph_1_1Results.html">Results</a>&lt; Node_, Weight_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran_1_1build__snn__graph.html#a232e3a8285f1e19655e9bdc448c3a9e0">compute</a> (const std::vector&lt; std::vector&lt; Index_ &gt; &gt; &amp;neighbors, const <a class="el" href="structscran_1_1build__snn__graph_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a232e3a8285f1e19655e9bdc448c3a9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01100b35520ffa85d18a78a588945aff" id="r_a01100b35520ffa85d18a78a588945aff"><td class="memTemplParams" colspan="2">template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Dim_ , typename Index_ , typename Float_ &gt; </td></tr>
<tr class="memitem:a01100b35520ffa85d18a78a588945aff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1build__snn__graph_1_1Results.html">Results</a>&lt; Node_, Weight_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran_1_1build__snn__graph.html#a01100b35520ffa85d18a78a588945aff">compute</a> (const knncolle::Prebuilt&lt; Dim_, Index_, Float_ &gt; &amp;prebuilt, const <a class="el" href="structscran_1_1build__snn__graph_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a01100b35520ffa85d18a78a588945aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cfc0034027c4d19b30295255014cbb" id="r_a81cfc0034027c4d19b30295255014cbb"><td class="memTemplParams" colspan="2">template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Dim_ , typename Index_ , typename Value_ , typename Float_ &gt; </td></tr>
<tr class="memitem:a81cfc0034027c4d19b30295255014cbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1build__snn__graph_1_1Results.html">Results</a>&lt; Node_, Weight_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran_1_1build__snn__graph.html#a81cfc0034027c4d19b30295255014cbb">compute</a> (Dim_ num_dims, Index_ num_cells, const Value_ *data, const knncolle::Builder&lt; knncolle::SimpleMatrix&lt; Dim_, Index_, Value_ &gt;, Float_ &gt; &amp;knn_method, const <a class="el" href="structscran_1_1build__snn__graph_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a81cfc0034027c4d19b30295255014cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Build a shared nearest-neighbor graph with cells as nodes. </p>
<p>In a shared nearest neighbor graph, pairs of cells are connected to each other by an edge with weight determined from their shared nearest neighbors. If two cells are close together but have distinct sets of neighbors, the corresponding edge is downweighted as the two cells are unlikely to be part of the same neighborhood. In this manner, highly weighted edges will form within highly interconnected neighborhoods where many cells share the same neighbors. This provides a more sophisticated definition of similarity between cells compared to a simpler (unweighted) nearest neighbor graph that just focuses on immediate proximity. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a610e9e4165fe86b9903b9dd368695358" name="a610e9e4165fe86b9903b9dd368695358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610e9e4165fe86b9903b9dd368695358">&#9670;&#160;</a></span>Scheme</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">enum</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">class</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#a610e9e4165fe86b9903b9dd368695358">scran::build_snn_graph::Scheme</a> : <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">char</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Choices for the edge weighting scheme during graph construction. Let <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$k$" src="form_0.png"/></picture> be the number of nearest neighbors for each node.</p>
<ul>
<li><code>RANKED</code> defines the weight between two nodes as <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$k - r/2$" src="form_1.png"/></picture> where <picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$r$" src="form_2.png"/></picture> is the smallest sum of ranks for any shared neighboring node (Xu and Su, 2015). For the purposes of this ranking, each node has a rank of zero in its own nearest-neighbor set. More shared neighbors, or shared neighbors that are close to both observations, will generally yield larger weights.</li>
<li><code>NUMBER</code> defines the weight between two nodes as the number of shared nearest neighbors between them. The weight can range from zero to $k + 1$, as the node itself is included in its own nearest-neighbor set. This is a simpler scheme that is also slightly faster but does not account for the ranking of neighbors within each set.</li>
<li><code>JACCARD</code> defines the weight between two nodes as the Jaccard index of their neighbor sets, motivated by the algorithm used by the <a href="https://cran.r-project.org/package=seurat"><b>Seurat</b> R package</a>. This weight can range from zero to 1, and is a monotonic transformation of the weight used by <code>NUMBER</code>.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">Xu</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">C</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">and</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">Su</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">Z</a> (2015). <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">Identification</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">of</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">cell</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">types</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">from</a> single-cell <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">transcriptomes</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">using</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">a</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">novel</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">clustering</a> <a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">method</a>. <em><a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">Bioinformatics</a></em> 31, 1974-80 </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad7bb15027d07c0c217c0082746bb69ed" name="ad7bb15027d07c0c217c0082746bb69ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bb15027d07c0c217c0082746bb69ed">&#9670;&#160;</a></span>compute() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, class GetNeighbors_ , class GetIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran::build_snn_graph::compute </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetNeighbors_&#160;</td>
          <td class="paramname"><em>get_neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetIndex_&#160;</td>
          <td class="paramname"><em>get_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran_1_1build__snn__graph_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscran_1_1build__snn__graph_1_1Results.html">Results</a>&lt; Node_, Weight_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Node_</td><td>Integer type for the node indices. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type for the edge weights. </td></tr>
    <tr><td class="paramname">GetNeighbors_</td><td>Function that accepts a <code>size_t</code> cell index and returns a (const reference to) a container-like object. The container should be iterable in a range-based for loop, support the <code>[]</code> operator, and have a <code><a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">size()</a></code> method. </td></tr>
    <tr><td class="paramname">GetIndex_</td><td>Function that accepts an element of the container type returned by <code>GetNeighbors_</code> and returns <code>Node_</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num_cells</td><td>Number of cells in the dataset. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">get_neighbors</td><td>Function that accepts an integer cell index in <code>[0, num_cells)</code> and returns a container of that cell's neighbors. Each element of the container corresponds to a neighbor, and neighbors should be sorted by increasing distance from the cell. It is generally expected that the same number of neighbors are present for each cell, though differences between cells are supported. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">get_index</td><td>Function to return the index of each neighbor, given an element of the container returned by <code>get_neighbors</code>. In trivial cases, this is the identity function but it can be more complex depending on the contents of the inner container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options for graph construction. Note that <code><a class="el" href="structscran_1_1build__snn__graph_1_1Options.html#ac9e9a14d4f7d3b0107b42865f0757316">Options::num_neighbors</a></code> is ignored here. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>On output, the edges and weights of the SNN graph. The input value is ignored so this can be re-used across multiple calls to <code><a class="el" href="namespacescran_1_1build__snn__graph.html#ad7bb15027d07c0c217c0082746bb69ed">compute()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add74d72ecdcd9e644641c06f2760a6cf" name="add74d72ecdcd9e644641c06f2760a6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add74d72ecdcd9e644641c06f2760a6cf">&#9670;&#160;</a></span>compute() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Index_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1build__snn__graph_1_1Results.html">Results</a>&lt; Node_, Weight_ &gt; scran::build_snn_graph::compute </td>
          <td>(</td>
          <td class="paramtype">const knncolle::NeighborList&lt; Index_, Distance_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran_1_1build__snn__graph_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload to enable convenient usage with pre-computed neighbors from <b>knncolle</b>. Distances are ignored here; only the ordering of neighbor indices is used.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Node_</td><td>Integer type for the node indices. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type for the edge weights. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the neighbor indices. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Floating-point type for the distances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighbors</td><td>Vector of nearest-neighbor search results for each cell. Each entry is a pair containing a vector of neighbor indices and a vector of distances to those neighbors. Neighbors should be sorted by increasing distance. It is generally expected that the same number of neighbors are present for each cell, though differences between cells are supported. </td></tr>
    <tr><td class="paramname">options</td><td>Further options for graph construction. Note that <code><a class="el" href="structscran_1_1build__snn__graph_1_1Options.html#ac9e9a14d4f7d3b0107b42865f0757316">Options::num_neighbors</a></code> is ignored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges and weights of the SNN graph. </dd></dl>

</div>
</div>
<a id="a232e3a8285f1e19655e9bdc448c3a9e0" name="a232e3a8285f1e19655e9bdc448c3a9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232e3a8285f1e19655e9bdc448c3a9e0">&#9670;&#160;</a></span>compute() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Node_  = int, typename Weight_  = double, typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1build__snn__graph_1_1Results.html">Results</a>&lt; Node_, Weight_ &gt; scran::build_snn_graph::compute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Index_ &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran_1_1build__snn__graph_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload to enable convenient usage with pre-computed neighbors from <b>knncolle</b>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Node_</td><td>Integer type for the node indices. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type for the edge weights. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the neighbor indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighbors</td><td>Vector of vectors of indices for the neighbors for each cell, sorted by increasing distance. It is generally expected that the same number of neighbors are present for each cell, though differences between cells are supported. </td></tr>
    <tr><td class="paramname">options</td><td>Further options for graph construction. Note that <code><a class="el" href="structscran_1_1build__snn__graph_1_1Options.html#ac9e9a14d4f7d3b0107b42865f0757316">Options::num_neighbors</a></code> is ignored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges and weights of the SNN graph. </dd></dl>

</div>
</div>
<a id="a01100b35520ffa85d18a78a588945aff" name="a01100b35520ffa85d18a78a588945aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01100b35520ffa85d18a78a588945aff">&#9670;&#160;</a></span>compute() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Dim_ , typename Index_ , typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1build__snn__graph_1_1Results.html">Results</a>&lt; Node_, Weight_ &gt; scran::build_snn_graph::compute </td>
          <td>(</td>
          <td class="paramtype">const knncolle::Prebuilt&lt; Dim_, Index_, Float_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>prebuilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran_1_1build__snn__graph_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload to enable convenient usage with a prebuilt nearest-neighbor search index from <b>knncolle</b>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Node_</td><td>Integer type for the node indices. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type for the edge weights. </td></tr>
    <tr><td class="paramname">Dim_</td><td>Integer type for the dimension index. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the cell index. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the distances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prebuilt</td><td>A prebuilt nearest-neighbor search index on the cells of interest. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options for graph construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges and weights of the SNN graph. </dd></dl>

</div>
</div>
<a id="a81cfc0034027c4d19b30295255014cbb" name="a81cfc0034027c4d19b30295255014cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cfc0034027c4d19b30295255014cbb">&#9670;&#160;</a></span>compute() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Node_  = DefaultNode, typename Weight_  = DefaultWeight, typename Dim_ , typename Index_ , typename Value_ , typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1build__snn__graph_1_1Results.html">Results</a>&lt; Node_, Weight_ &gt; scran::build_snn_graph::compute </td>
          <td>(</td>
          <td class="paramtype">Dim_&#160;</td>
          <td class="paramname"><em>num_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value_ *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const knncolle::Builder&lt; knncolle::SimpleMatrix&lt; Dim_, Index_, Value_ &gt;, Float_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>knn_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran_1_1build__snn__graph_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload to enable convenient usage with a column-major array of cell coordinates.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Node_</td><td>Integer type for the node indices. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type for the edge weights. </td></tr>
    <tr><td class="paramname">Dim_</td><td>Integer type for the dimension index. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the cell index. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type for the input data. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the distances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num_dims</td><td>Number of dimensions for the cell coordinates. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_cells</td><td>Number of cells in the dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a <code>num_dims</code>-by-<code>num_cells</code> column-major array of cell coordinates where rows are dimensions and columns are cells. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">knn_method</td><td>Specification of the nearest-neighbor search algorithm, e.g., <code>knncolle::VptreeBuilder</code>, <code>knncolle::KmknnBuilder</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options for graph construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges and weights of the SNN graph. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
